<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pneumatic Test Timer</title>

  <script src="https://unpkg.com/html5-qrcode"></script>

  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 16px; background:#f6f7fb; }
    * { box-sizing: border-box;}
    .wrap { max-width: 520px; margin: 0 auto; }
    h2 { margin: 0 0 12px; }
    .card { background: #fff; border-radius: 14px; padding: 14px; box-shadow: 0 8px 20px rgba(0,0,0,.06); margin-bottom: 12px; }
    .row { display:flex; gap: 10px; }
    .row > * { flex: 1; }
    button, input, select, textarea { width:100%; padding: 12px; font-size: 16px; border-radius: 10px; border: 1px solid #d9dbe3; }
    button { border:none; cursor:pointer; background:#04922a; color:#fff; }
    button:disabled { background:#9aa3b2; cursor:not-allowed; }
    .btn-secondary { background:#274f90; }
    .btn-passed { background:#08820a; }
    .btn-warn { background:#d60c09; }
    .btn-stop { background: #7f1d1d; }
    .btn-stop:hover {background: #991b1b}
    
    .small { font-size: 12px; color:#6b7280; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .time { font-size: 46px; text-align:center; padding: 10px 0; letter-spacing: 2px; }
    .status { margin-top: 6px; font-size: 13px; }
    .error { color:#b91c1c; }
    .ok { color:#06a313; }
    .kv { font-size: 14px; line-height: 1.35; }
    .kv b { display:inline-block; min-width: 120px; }
    .divider { height: 1px; background:#eceef4; margin: 12px 0; }
    .pill { display:block; padding: 4px 0; color:#000000; font-size: 18px; font-weight: 700; }
    .page { display:none; }
    .page.active { display:block; }
    .stepbar { display:flex; gap:8px; margin: 0 0 10px; }
    .step { flex:1; height:8px; border-radius:999px; background:#e5e7eb; overflow:hidden; }
    .step > div { height:100%; width:0%; background:#111827; }
    .step.done > div { width:100%; }
    .step.current > div { width:60%; }
    .hint { margin-top: 8px; }
    textarea { resize: vertical; min-height: 90px; }
    

    /* Simple modal */
    #leakModal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.4);
      padding: 16px;
    }

    /* Center box */
    #leakModal .box {
      width: 100%;
      max-width: 520px;     
      margin: 10vh auto;    /* this centers it */
      background: #fff;
      padding: 14px;
      border-radius: 14px;

      max-height: 80vh;     /* height limit */
      overflow-y: auto;     /* scroll inside box */
    }

    #employee-info { display: none; }

    #leakRemark {
      width: 100%;
      max-width: 100%;
      min-height: 90px;
      resize: vertical;
      overflow-wrap: break-word;
    }

    #remarkLabel { transition: all 0.2s ease; }

    @media (max-width: 600px) {
      #leakModal .box {      
        margin: 5vh auto;
        width: 100%;
      }
    }

    /* Loading overlay */
    #loadingOverlay{
      display:none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 16px;
    }

    #loadingOverlay.show{
      display: flex;
    }

    #loadingOverlay .loadingBox{
      width: 100%;
      max-width: 360px;
      background: #fff;
      border-radius: 14px;
      padding: 16px;
      text-align: center;
      box-shadow: 0 10px 24px rgba(0,0,0,.12);
    }

    .spinner{
      width: 44px;
      height: 44px;
      border: 5px solid #e5e7eb;
      border-top-color: #111827;
      border-radius: 50%;
      margin: 0 auto 10px;
      animation: spin 0.9s linear infinite;
    }

    @keyframes spin{
      to { transform: rotate(360deg); }
    }

    .center-image {
      display: flex;
      justify-content: center;
      margin: 12px 0;
    }

    .center-image img {
      max-width: 160px;     /* control size */
      width: 100%;
      height: auto;
    }


  </style>
</head>

<body>
  <div class="wrap">
    <h2>Pneumatic Test Timer</h2>

    <div class="stepbar">
      <div class="step" id="step1"><div></div></div>
      <div class="step" id="step2"><div></div></div>
      <div class="step" id="step3"><div></div></div>
    </div>

    <!-- PAGE 1 -->
    <div class="page card" id="page1">
      <div class="pill">Scan Vessel QR Code</div>
      <div class="divider"></div>

      <div id="projectReader" style="width:100%"></div>

      <div class="divider"></div>

      <div class="row">
        <button id="btnProjectScanToggle" class="btn-secondary">Start Scan</button>
      </div>

      <div style="height:10px"></div>

      <div class="divider"></div>

      <div class="kv">
        <div><b>Project Name:</b> <span class="mono" id="projNameText">-</span></div>
        <div><b>Serial No:</b> <span class="mono" id="serialText">-</span></div>
        <div><b>Type:</b> <span class="mono" id="typeText">-</span></div>
      </div>

      <br>
      <div class="status" id="projectScanStatus"></div>

      <div class="divider"></div>

      <div class="row">
        <button id="btnOkProject" disabled>OK</button>
      </div>

    <!-- PAGE 2 -->
    <div class="page card" id="page2">
      <div class="pill">Scan Employee QR</div>
      <div class="divider"></div>

      <div id="employeeReader" style="width:100%"></div>

      <div class="divider"></div>

      <div class="row">
        <button id="btnEmpScanToggle" class="btn-secondary">Start Scan</button>
      </div>

      <div style="height:10px"></div>

      <div class="divider"></div>

      <div class="kv">
        <div><b>Employee ID:</b> <span class="mono" id="empIdText">-</span></div>
        <div><b>Name:</b> <span class="mono" id="empNameText">-</span></div>
        <div><b>Station:</b> <span class="mono" id="empStationText">-</span></div>
      </div>

      <div class="status" id="empScanStatus"></div>

      <div class="divider"></div>

      <div class="row">
        <button id="btnOkEmployee" disabled>OK</button>
      </div>

    <!-- PAGE 3 -->
    <div class="page card" id="page3">
      <div class="pill">Timer</div>
      <div class="divider"></div>

      <div class="kv">
        <div><b>Serial No:</b> <span class="mono" id="p3Serial">-</span></div>
        <div><b>Project:</b> <span class="mono" id="p3Project">-</span></div>
        <div><b>Type:</b> <span class="mono" id="p3Type">-</span></div>
        <div><b>Employee:</b> <span class="mono" id="p3Emp">-</span></div>
        <div><b>Station:</b> <span class="mono" id="p3Station">-</span></div>
      </div>

      <div class="divider"></div>

      <!-- Center image -->
      <div class="center-image">
        <img src="images/Vessel-1.jpeg" alt="Pneumatic Test" />
      </div>

      <div class="divider"></div>

      <div class="time mono" id="timerText">00:00:00</div>

      <div class="row">
        <button id="btnStart" disabled>Start</button>
      </div>

      <div style="height:10px"></div>
      <div class="row">
        <button id="btnPass" class="btn-passed" disabled>Pass</button>
        <button id="btnLeak" class="btn-warn" disabled>Leak</button>
      </div>

      <div class="divider"></div>

       <div class="kv" id="employee-info">
        <div><b>Segment ID:</b> <span class="mono" id="segmentIdText">-</span></div>
        <div><b>Start:</b> <span class="mono" id="startTsText">-</span></div>
        <div><b>End:</b> <span class="mono" id="stopTsText">-</span></div>
      </div>

      <div class="status" id="actionStatus"></div>
    </div>
  </div>

  <!-- Leak modal -->
  <div id="leakModal">
    <div class="box">
      <div class="pill">Leak Details</div>
      <div class="divider"></div>

      <label class="small">Reason</label>
      <select id="leakReason">
        <option value="">-- Select --</option>
        <option value="rework">Rework</option>
        <option value="npt">NPT</option>
        <option value="others">Others</option>
      </select>

      <div style="height:10px"></div>

      <label class="small" id="remarkLabel" style="display:none">Remark (required if the reason is "Others")</label>
      <textarea 
        id="leakRemark" 
        style="display:none"
      ></textarea>

      <div class="divider"></div>

      <div class="row">
        <button id="btnLeakCancel" class="btn-secondary" type="button">Cancel</button>
        <button id="btnLeakConfirm" type="button">Confirm</button>
      </div>

      <div class="status" id="leakModalStatus"></div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div id="loadingOverlay">
    <div class="loadingBox">
      <div class="spinner"></div>
      <div id="loadingText">Submitting…</div>
      <div class="small" style="margin-top:6px; color:#6b7280;">Please wait</div>
    </div>
  </div>


  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import {
      getFirestore, doc, setDoc, updateDoc, addDoc, collection, serverTimestamp,
      query, where, orderBy, limit, getDocs
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    /***************
     * FIREBASE CONFIG (your project)
     ***************/
    const firebaseConfig = {
      apiKey: "AIzaSyDnYqCLkMfk3WrUZWqT6HM72hxKdsu7y_A",
      authDomain: "pneumatictracking.firebaseapp.com",
      projectId: "pneumatictracking",
      storageBucket: "pneumatictracking.firebasestorage.app",
      messagingSenderId: "392460221400",
      appId: "1:392460221400:web:605da9e55bebd7200210ad"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    async function upsertSerialHeader(serial, projectName, vesselType) {
      const ref = doc(db, "serial_timelines", serial);
      await setDoc(ref, {
        serial_number: serial,
        project_name: projectName,
        vessel_type: vesselType,
        lastUpdatedAt: serverTimestamp()
      }, { merge: true });
    }

    /***************
     * STORAGE KEYS (resume if refresh mid-test)
     ***************/
    const LS = {
      running: "ptt_running",
      startISO: "ptt_startISO",
      startEpoch: "ptt_startEpoch",
      serial: "ptt_serial",
      segmentId: "ptt_segmentId",
      projectData: "ptt_projectData",
      employeeData: "ptt_employeeData",
      confirmedProject: "ptt_confirmedProject",
      confirmedEmployee: "ptt_confirmedEmployee"
    };

    /***************
     * STATE
     ***************/
    let projectData = { version:"", projectName:"", serial:"", type:"" };
    let employeeData = { version:"", empId:"", empName:"", station:"" };
    let projectConfirmed = false;
    let employeeConfirmed = false;

    let timerInterval = null;
    let elapsedSec = 0;
    let isRunning = false;

    // Segment-based model (for charting)
    let currentTestSegmentId = null;
    let startTestingISO = null;

    const el = (id) => document.getElementById(id);

    function setStatus(node, msg, kind = "ok") {
      node.className = "status " + (kind === "error" ? "error" : "ok");
      node.textContent = msg;
    }

    function formatHHMMSS(totalSec) {
      const h = Math.floor(totalSec / 3600);
      const m = Math.floor((totalSec % 3600) / 60);
      const s = totalSec % 60;
      const pad = (n) => String(n).padStart(2, "0");
      return `${pad(h)}:${pad(m)}:${pad(s)}`;
    }

    function renderTimer() {
      el("timerText").textContent = formatHHMMSS(elapsedSec);
    }

    function setStep(stepIndex) {
      const s1 = el("step1"), s2 = el("step2"), s3 = el("step3");
      [s1,s2,s3].forEach(s => s.className = "step");
      if (stepIndex === 1) { s1.classList.add("current"); }
      if (stepIndex === 2) { s1.classList.add("done"); s2.classList.add("current"); }
      if (stepIndex === 3) { s1.classList.add("done"); s2.classList.add("done"); s3.classList.add("current"); }

      ["page1","page2","page3"].forEach(pid => el(pid).classList.remove("active"));
      el(`page${stepIndex}`).classList.add("active");
    }

    function normalizeType(t) {
      const raw = String(t || "").trim().toUpperCase();
      const map = {
        "EVAPORATOR": "EVAPORATOR",
        "OIL SEPARATOR": "OIL SEPARATOR",
        "OIL_SEPARATOR": "OIL SEPARATOR",
        "OILSEPARATOR": "OIL SEPARATOR",
        "CONDENSER": "CONDENSER",
        "ECONOMIZER": "ECONOMIZER"
      };
      return map[raw] || null;
    }

    function diffSeconds(isoStart, isoEnd) {
      const a = new Date(isoStart).getTime();
      const b = new Date(isoEnd).getTime();
      return Math.max(0, Math.round((b - a) / 1000));
    }

    


    /***************
     * PARSERS
     ***************/
    // Vessel: version;project_name;serial_number;type
    function parseProjectQR(text) {
      const parts = String(text).trim().split(";");
      if (parts.length < 4) return null;

      const version = parts[0].trim();
      const projectName = parts[1].trim();
      const serial = parts[2].trim();
      const type = normalizeType(parts[3]);

      if (!version || !projectName || !serial || !type) return null;
      return { version, projectName, serial, type };
    }

    // Employee: version;employee_id;employee_name;station
    function parseEmployeeQR(text) {
      const parts = String(text).trim().split(";");
      if (parts.length < 4) return null;

      const version = parts[0].trim().toUpperCase();
      const empId = parts[1].trim();
      const empName = parts[2].trim().replaceAll("_", " ");
      const station = parts[3].trim();

      if (version !== "EMP") return null;
      if (!empId || !empName || !station) return null;

      return { version, empId, empName, station };
    }

    function setButtonsDisabled(disabled) {
      el("btnStart").disabled = disabled;
      el("btnPass").disabled = disabled;
      el("btnLeak").disabled = disabled;
    }

    function showLoading(text = "Submitting…") {
      el("loadingText").textContent = text;
      el("loadingOverlay").classList.add("show");
    }

    function hideLoading() {
      el("loadingOverlay").classList.remove("show");
    }

    function wait(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }


    /***************
     * UI PAINT
     ***************/
    function paintProjectUI() {
      el("projNameText").textContent = projectData.projectName || "-";
      el("serialText").textContent = projectData.serial || "-";
      el("typeText").textContent = projectData.type || "-";
    }

    function paintEmployeeUI() {
      el("empIdText").textContent = employeeData.empId || "-";
      el("empNameText").textContent = employeeData.empName || "-";
      el("empStationText").textContent = employeeData.station || "-";
    }

    function paintPage3Header() {
      el("p3Serial").textContent = projectData.serial || "-";
      el("p3Project").textContent = projectData.projectName || "-";
      el("p3Type").textContent = projectData.type || "-";
      el("p3Emp").textContent = employeeData.empId ? `${employeeData.empName} (${employeeData.empId})` : "-";
      el("p3Station").textContent = employeeData.station || "-";
    }

    function canEnableTimerActions() {
      const ready = projectConfirmed && employeeConfirmed;
      el("btnStart").disabled = !ready || isRunning;
      el("btnPass").disabled = !isRunning;
      el("btnLeak").disabled = !isRunning;
    }

    function persistWizardState() {
      localStorage.setItem(LS.projectData, JSON.stringify(projectData));
      localStorage.setItem(LS.employeeData, JSON.stringify(employeeData));
      localStorage.setItem(LS.confirmedProject, projectConfirmed ? "1" : "0");
      localStorage.setItem(LS.confirmedEmployee, employeeConfirmed ? "1" : "0");
    }

    function persistRunState() {
      localStorage.setItem(LS.running, isRunning ? "1" : "0");
      localStorage.setItem(LS.startISO, startTestingISO || "");
      localStorage.setItem(LS.startEpoch, localStorage.getItem(LS.startEpoch) || "");
      localStorage.setItem(LS.serial, projectData.serial || "");
      localStorage.setItem(LS.segmentId, currentTestSegmentId || "");
    }

    function clearAllState() {
      Object.values(LS).forEach(k => localStorage.removeItem(k));
    }

    /***************
     * SCANNERS (camera + upload)
     ***************/
    const projectScanner = new Html5Qrcode("projectReader");
    const employeeScanner = new Html5Qrcode("employeeReader");

    let projectScanning = false;

    async function toggleProjectScan() {
      const btn = el("btnProjectScanToggle");

      // STOP scanning
      if (projectScanning) {
        try { await projectScanner.stop(); } catch {}
        projectScanning = false;

        btn.textContent = "Start Scan";
        btn.classList.remove("btn-stop");
        btn.classList.add("btn-secondary");

        setStatus(el("projectScanStatus"), "Scan stopped.", "ok");
        return;
      }

      // START scanning
      try {
        setStatus(el("projectScanStatus"), "Starting camera...", "ok");
        btn.disabled = true;

        await projectScanner.start(
          { facingMode: "environment" },
          { fps: 10, qrbox: { width: 250, height: 250 } },
          async (decodedText) => {
            const parsed = parseProjectQR(decodedText);
            if (!parsed) {
              setStatus(el("projectScanStatus"), "Invalid Vessel QR.", "error");
              return;
            }

            projectData = parsed;
            projectConfirmed = false;
            paintProjectUI();
            setStatus(el("projectScanStatus"), "Vessel QR parsed. Press OK.", "ok");
            el("btnOkProject").disabled = false;

            // Auto stop after success
            await projectScanner.stop();
            projectScanning = false;

            btn.textContent = "Start Scan";
            btn.classList.remove("btn-stop");
            btn.classList.add("btn-secondary");
          }
        );

        projectScanning = true;
        btn.textContent = "Stop Scan";
        btn.classList.remove("btn-secondary");
        btn.classList.add("btn-stop");

      } catch (e) {
        console.error(e);
        setStatus(el("projectScanStatus"), "Camera start failed.", "error");
        projectScanning = false;

        btn.textContent = "Start Scan";
        btn.classList.remove("btn-stop");
        btn.classList.add("btn-secondary");
      } finally {
        btn.disabled = false;
      }
    }


    el("btnProjectScanToggle").addEventListener("click", toggleProjectScan);

    let empScanning = false;

    async function toggleEmpScan() {
      const btn = el("btnEmpScanToggle");

      if (empScanning) {
        try { await employeeScanner.stop(); } catch {}
        empScanning = false;

        btn.textContent = "Start Scan";
        btn.classList.remove("btn-stop");
        btn.classList.add("btn-secondary");

        setStatus(el("empScanStatus"), "Scan stopped.", "ok");
        return;
      }

      try {
        setStatus(el("empScanStatus"), "Starting camera...", "ok");
        btn.disabled = true;

        await employeeScanner.start(
          { facingMode: "environment" },
          { fps: 10, qrbox: { width: 250, height: 250 } },
          async (decodedText) => {
            const parsed = parseEmployeeQR(decodedText);
            if (!parsed) {
              setStatus(el("empScanStatus"), "Invalid Employee QR.", "error");
              return;
            }

            employeeData = parsed;
            employeeConfirmed = false;
            paintEmployeeUI();
            setStatus(el("empScanStatus"), "Employee QR parsed. Press OK.", "ok");
            el("btnOkEmployee").disabled = false;

            await employeeScanner.stop();
            empScanning = false;

            btn.textContent = "Start Scan";
            btn.classList.remove("btn-stop");
            btn.classList.add("btn-secondary");
          }
        );

        empScanning = true;
        btn.textContent = "Stop Scan";
        btn.classList.remove("btn-secondary");
        btn.classList.add("btn-stop");

      } catch (e) {
        console.error(e);
        setStatus(el("empScanStatus"), "Camera start failed.", "error");
        empScanning = false;

        btn.textContent = "Start Scan";
        btn.classList.remove("btn-stop");
        btn.classList.add("btn-secondary");
      } finally {
        btn.disabled = false;
      }
    }


    el("btnEmpScanToggle").addEventListener("click", toggleEmpScan);


    el("leakReason").addEventListener("change", () => {
      const show = el("leakReason").value === "others";

      el("leakRemark").style.display = show ? "block" : "none";
      el("remarkLabel").style.display = show ? "block" : "none";

      if (!show) {
        el("leakRemark").value = ""; // clear remark if not needed
      }
   });

    /***************
     * SEGMENT MODEL (for chart)
     * Path: serial_timelines/{serial}/segments/{segmentId}
     * segment_type: "TEST" or "LEAK"
     ***************/

    function segmentsColRef(serial) {
      return collection(db, "serial_timelines", serial, "segments");
    }

    function segmentDocRef(serial, segmentId) {
      return doc(db, "serial_timelines", serial, "segments", segmentId);
    }

    async function closeOpenLeakIfAny(serial, newStartTestingISO) {
      const col = segmentsColRef(serial);
      const q = query(
        col,
        where("segment_type", "==", "LEAK"),
        where("end_time", "==", null),
        orderBy("start_time", "desc"),
        limit(1)
      );
      const snap = await getDocs(q);
      if (snap.empty) return;

      const leakDoc = snap.docs[0];
      const leakData = leakDoc.data();
      const endISO = newStartTestingISO;
      const dur = diffSeconds(leakData.start_time, endISO);

      await updateDoc(leakDoc.ref, {
        end_time: endISO,
        duration_sec: dur,
        lastUpdatedAt: serverTimestamp()
      });
    }

    async function createTestSegmentStart() {
      // When a new TEST starts, it also closes any open LEAK segment for same serial.
      startTestingISO = new Date().toISOString();
      await closeOpenLeakIfAny(projectData.serial, startTestingISO);

      const col = segmentsColRef(projectData.serial);
      const seg = await addDoc(col, {
        segment_type: "TEST",
        start_time: startTestingISO,
        end_time: null,
        duration_sec: null,

        // status for TEST: running / passed / leak
        status: "running",

        // project context
        project_version: projectData.version,
        project_name: projectData.projectName,
        serial_number: projectData.serial,
        vessel_type: projectData.type,

        // who started
        employee_version: employeeData.version,
        employee_id: employeeData.empId,
        employee_name: employeeData.empName,
        station: employeeData.station,

        // remarks (pass remark only)
        remark: null,

        createdAt: serverTimestamp(),
        lastUpdatedAt: serverTimestamp()
      });

      await upsertSerialHeader(
        projectData.serial,
        projectData.projectName,
        projectData.type
      );

      currentTestSegmentId = seg.id;
      el("segmentIdText").textContent = currentTestSegmentId;
      el("startTsText").textContent = startTestingISO;
      el("stopTsText").textContent = "-";
    }

      


    async function finalizeTestAsPass(remark) {
      const endISO = new Date().toISOString();
      const dur = diffSeconds(startTestingISO, endISO);
      const ref = segmentDocRef(projectData.serial, currentTestSegmentId);

      await updateDoc(ref, {
        end_time: endISO,
        duration_sec: dur,
        status: "passed",
        remark: remark ? remark : null,
        lastUpdatedAt: serverTimestamp()
      });

      el("stopTsText").textContent = endISO;
    }

    async function openLeakDialog() {
      return new Promise((resolve) => {
        const modal = el("leakModal");
        const reasonEl = el("leakReason");
        const remarkEl = el("leakRemark");
        const remarkLabel = el("remarkLabel");
        const statusEl = el("leakModalStatus");

        reasonEl.value = "";
        remarkEl.value = "";
        remarkEl.style.display = "none";
        remarkLabel.style.display = "none";
        statusEl.textContent = "";
        statusEl.className = "status";

        modal.style.display = "block";

        const cleanup = () => {
          modal.style.display = "none";
          el("btnLeakCancel").onclick = null;
          el("btnLeakConfirm").onclick = null;
        };

        el("btnLeakCancel").onclick = () => {
          cleanup();
          resolve(null);
        };

        el("btnLeakConfirm").onclick = () => {
          const reason = reasonEl.value.trim();
          const remark = remarkEl.value.trim();

          if (!reason) {
            statusEl.className = "status error";
            statusEl.textContent = "Please select a leak reason.";
            return;
          }
          if (reason === "others" && !remark) {
            statusEl.className = "status error";
            statusEl.textContent = "Remark is required when reason is 'Others'.";
            return;
          }

          cleanup();
          resolve({ reason, remark: remark || null });
        };
      });
    }

    async function finalizeTestAsLeakAndOpenLeakSegment() {
      const leakStartISO = new Date().toISOString();
      const durTesting = diffSeconds(startTestingISO, leakStartISO);

      const leakInfo = await openLeakDialog();
      if (!leakInfo) return false; // cancelled

      // 1) Close TEST segment as leak
      const testRef = segmentDocRef(projectData.serial, currentTestSegmentId);
      await updateDoc(testRef, {
        end_time: leakStartISO,
        duration_sec: durTesting,
        status: "leak",
        remark: leakInfo.remark, // you can keep this as remark for test end if you want
        leak_reason: leakInfo.reason,
        lastUpdatedAt: serverTimestamp()
      });

      // 2) Open LEAK segment (end_time will be filled automatically on next TEST start)
      const col = segmentsColRef(projectData.serial);
      await addDoc(col, {
        segment_type: "LEAK",
        start_time: leakStartISO,
        end_time: null,
        duration_sec: null,

        // leak details
        reason: leakInfo.reason,
        remark: leakInfo.remark,

        // project context
        project_name: projectData.projectName,
        serial_number: projectData.serial,
        vessel_type: projectData.type,

        // who recorded the leak
        employee_id: employeeData.empId,
        employee_name: employeeData.empName,
        station: employeeData.station,

        createdAt: serverTimestamp(),
        lastUpdatedAt: serverTimestamp()
      });

      el("stopTsText").textContent = leakStartISO;
      return true;
    }

    /***************
     * TIMER CONTROL
     ***************/
    function startTimer() {
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        elapsedSec += 1;
        renderTimer();
      }, 1000);
    }

    function stopTimer() {
      clearInterval(timerInterval);
      timerInterval = null;
    }

    /***************
     * WIZARD BUTTONS
     ***************/

    el("btnOkProject").addEventListener("click", () => {
      projectConfirmed = true;
      el("btnOkProject").disabled = true;
      persistWizardState();
      setStep(2);
      setStatus(el("empScanStatus"), "Ready to scan employee QR code.", "ok");
    });

    el("btnOkEmployee").addEventListener("click", () => {
      employeeConfirmed = true;
      el("btnOkEmployee").disabled = true;
      persistWizardState();
      setStep(3);
      paintPage3Header();
      setStatus(el("actionStatus"), "Ready. Press Start to begin.", "ok");
      canEnableTimerActions();
      el("btnStart").disabled = false;
    });

    /***************
     * TIMER PAGE BUTTONS
     ***************/
    el("btnStart").addEventListener("click", async () => {
      if (!(projectConfirmed && employeeConfirmed)) return;
      if (isRunning) return;

      //  Lock immediately (prevents double-click / weird state)
      isRunning = true;
      el("btnStart").disabled = true;   // optional extra lock
      canEnableTimerActions();

      // Start timer UI immediately (better UX)`
      elapsedSec = 0;
      renderTimer();
      startTimer();

      try {
        // Create TEST segment start + auto-close any open leak for same serial
        await createTestSegmentStart();

        // persist running state so you can recover if refresh
        localStorage.setItem(LS.startEpoch, String(Date.now()));
        persistWizardState();
        persistRunState();

        setStatus(el("actionStatus"), "Testing started.", "ok");
      } catch (e) {
        // ❌ If Firestore fails, rollback UI + state
        console.error(e);

        stopTimer();
        isRunning = false;
        canEnableTimerActions();
        el("btnStart").disabled = false;

        setStatus(el("actionStatus"), `Start failed: ${e?.message || e}`, "error");
      }
    });

    el("btnPass").addEventListener("click", async () => {
      try {
        if (!isRunning || !currentTestSegmentId) return;

        // Pause timer while asking remark
        isRunning = false;
        stopTimer();
        canEnableTimerActions();

        const remarkInput = prompt("Optional remark:", "");

        // Cancel and return to stopwatch
        if (remarkInput === null) {
          isRunning = true;
          startTimer();
          canEnableTimerActions();
          setStatus(el("actionStatus"), "PASS cancelled. Returned to stopwatch.", "ok");
          return;
        }

        // Lock buttons + show loading
        setButtonsDisabled(true);
        showLoading("Submitting PASS…");

        const remark = remarkInput.trim();
        await finalizeTestAsPass(remark);

        setStatus(el("actionStatus"), "Submitted test status. Returning to home page…", "ok");

        // Small polish delay
        await wait(1200);

        hideLoading();
        clearAllState();
        location.reload(); // or initAlwaysStartAtPage1()

      } catch (e) {
        console.error(e);

        hideLoading();
        setButtonsDisabled(false);

        // Rollback to running state if something failed
        isRunning = true;
        startTimer();
        canEnableTimerActions();

        setStatus(el("actionStatus"), `PASS failed: ${e?.message || e}`, "error");
      }
    });



    el("btnLeak").addEventListener("click", async () => {
      try {
        if (!isRunning || !currentTestSegmentId) return;

        // Stop UI timer while filling leak details
        isRunning = false;
        stopTimer();
        canEnableTimerActions();

        const ok = await finalizeTestAsLeakAndOpenLeakSegment();
        if (!ok) {
          // user cancelled leak → resume stopwatch
          isRunning = true;
          startTimer();
          canEnableTimerActions();
          setStatus(el("actionStatus"), "LEAK cancelled. Returned to stopwatch.", "ok");
          return;
        }

        // Lock buttons + show loading
        setButtonsDisabled(true);
        showLoading("Submitting LEAK…");

        setStatus(el("actionStatus"), "Submitted test status. Returning to home page…", "ok");
        await wait(1200);

        hideLoading();
        clearAllState();
        location.reload();

      } catch (e) {
        console.error(e);

        hideLoading();
        setButtonsDisabled(false);

        // Rollback to running state if error
        isRunning = true;
        startTimer();
        canEnableTimerActions();

        setStatus(el("actionStatus"), `LEAK failed: ${e?.message || e}`, "error");
      }
    });


    /***************
     * INIT / RESUME
     ***************/
    function loadWizardState() {
      try {
        const p = localStorage.getItem(LS.projectData);
        const e = localStorage.getItem(LS.employeeData);
        if (p) projectData = JSON.parse(p);
        if (e) employeeData = JSON.parse(e);
      } catch {}

      projectConfirmed = localStorage.getItem(LS.confirmedProject) === "1";
      employeeConfirmed = localStorage.getItem(LS.confirmedEmployee) === "1";

      paintProjectUI();
      paintEmployeeUI();

      // Decide which page to show
      if (!projectConfirmed) {
        setStep(1);
        el("btnOkProject").disabled = !projectData.serial;
        setStatus(el("projectScanStatus"), projectData.serial ? "Parsed. Press OK to confirm." : "Ready to scan vessel QR.", "ok");
        setStatus(el("empScanStatus"), "Ready to scan employee QR code.", "ok");
        return;
      }

      if (!employeeConfirmed) {
        setStep(2);
        el("btnOkEmployee").disabled = !employeeData.empId;
        setStatus(el("empScanStatus"), employeeData.empId ? "Parsed. Press OK to confirm." : "Ready to scan employee QR code.", "ok");
        return;
      }

      setStep(3);
      paintPage3Header();
      setStatus(el("actionStatus"), "Ready. Press Start to begin.", "ok");
    }

    function resumeIfRunning() {
      const running = localStorage.getItem(LS.running) === "1";
      if (!running) return;

      const serial = localStorage.getItem(LS.serial) || "";
      const segId = localStorage.getItem(LS.segmentId) || "";
      const startISO = localStorage.getItem(LS.startISO) || "";
      const startEpoch = parseInt(localStorage.getItem(LS.startEpoch) || "0", 10);

      if (!serial || !segId || !startISO || !startEpoch) return;

      // Restore run state
      currentTestSegmentId = segId;
      startTestingISO = startISO;

      const now = Date.now();
      elapsedSec = Math.max(0, Math.floor((now - startEpoch) / 1000));
      renderTimer();

      isRunning = true;
      startTimer();
      canEnableTimerActions();

      el("segmentIdText").textContent = currentTestSegmentId;
      el("startTsText").textContent = startTestingISO;
      el("stopTsText").textContent = "-";
      setStatus(el("actionStatus"), "Resumed running test (after refresh) ✅", "ok");
    }

    // Hook OK enable on parsed values
    // (If user scanned already and refreshes, OK should be enabled)
    function enableOkButtonsIfParsed() {
      el("btnOkProject").disabled = !projectData.serial || projectConfirmed;
      el("btnOkEmployee").disabled = !employeeData.empId || employeeConfirmed;
    }

    function initAlwaysStartAtPage1() {
    // Clear any persisted state
    clearAllState();

    // Reset in-memory state
    projectData = { version:"", projectName:"", serial:"", type:"" };
    employeeData = { version:"", empId:"", empName:"", station:"" };
    projectConfirmed = false;
    employeeConfirmed = false;

    isRunning = false;
    elapsedSec = 0;
    stopTimer();
    renderTimer();

    paintProjectUI();
    paintEmployeeUI();

    // Disable buttons
    el("btnOkProject").disabled = true;
    el("btnOkEmployee").disabled = true;
    el("btnStart").disabled = true;
    el("btnPass").disabled = true;
    el("btnLeak").disabled = true;

    // Go to Page 1
    setStep(1);
    setStatus(el("projectScanStatus"), "Ready to scan vessel QR.", "ok");
    setStatus(el("empScanStatus"), "Ready to scan employee QR.", "ok");
    setStatus(el("actionStatus"), "", "ok");
  }


    // Attach scans
    initAlwaysStartAtPage1();

    // When project parsed -> enable OK
    // (We already do in handlers; this covers any edge case)
  </script>
</body>
</html>
